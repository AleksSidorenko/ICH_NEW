# -*- coding: utf-8 -*-
"""Summary_16_111124.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OPMWUXICBJxAudy0nV9sdKNPoxTP969E

## Python fundamentals: Домашнее задание 30 (Python)

### 1.
Создайте класс Rectangle для представления прямоугольника.

Класс должен иметь атрибуты width (ширина) и height (высота) со значениями по умолчанию, а также методы calculate_area() для вычисления площади прямоугольника и calculate_perimeter() для вычисления периметра прямоугольника.

Переопределить методы __str__, __repr__.

Затем создайте экземпляр класса Rectangle и выведите информацию о нем,                           его площадь и периметр.
"""

class Rectangle:


    def __init__(self, width = 5, height = 6):
        self.width = width
        self.height = height

    def __str__(self):
        return f"Rectangle: width {self.width}, height {self.height}"

    def __repr__(self):
        return f"Rectangle: (width={self.width}, height={self.height})"

    def calculate_area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)


width, height = map(float, input("Enter width and height of Your rectangle with space: ").split())
print(width, height)
# user_rectangle = Rectangle(width, height)
user_rectangle = Rectangle()
print(f"\nSquare of Your rectangle is: {user_rectangle.calculate_area()}")
print(f"Rectangle's perimeter: {user_rectangle.perimeter()}")
print(user_rectangle)
print(repr(user_rectangle))

"""### 2.
Создайте класс BankAccount для представления банковского счета. Класс должен иметь атрибуты account_number (номер счета) и balance (баланс), а также методы deposit() для внесения денег на счет и withdraw() для снятия денег со счета. Затем создайте экземпляр класса BankAccount, внесите на счет некоторую сумму и снимите часть денег. Выведите оставшийся баланс. Не забудьте предусмотреть вариант, при котором при снятии баланс может стать меньше нуля. В этом случае уходить в минус не будем, вместо чего будем возвращать сообщение "Недостаточно средств на счете".


"""

class BankAccount:


    def __init__(self,account_number, balance):
        self.account_number = account_number
        self.balance = balance

    def deposit(self,amount):
        self.balance += amount
        return f"Your account balance is: {self.balance}"

    def withdraw(self,amount):
        if amount > self.balance:
            raise Exception("Insufficient balance")
        self.balance -= amount
        return f"Your account balance is: {self.balance}"


client = BankAccount(12345, 10000)
deposit_amount = float(input("Enter deposit amount: "))
print(client.deposit(deposit_amount))
try:
    withdraw_amount = float(input("Enter amount to withdraw: "))
    print(client.withdraw(withdraw_amount))
except Exception as e:
    print(f"Transaction cannot be completed due to insufficient funds")
print(f"Your current account balance is: {client.balance}")

class BankAccount:
    def __init__(self, account_number, balance = 0):
        self.balance = balance
        self.account_number = account_number


    def deposit(self, amount):
        self.balance += amount
        print(f"На счет {self.account_number} внесено {amount}. Текущий баланс: {self.balance}")


    def withdraw(self, amount):
        if amount > self.balance:
            print("Недостаточно средств на счете!")
        else:
            self.balance -= amount
            print(f"Со счета {self.account_number} снято {amount}. Текущий баланс: {self.balance}")

    def __str__(self):  # Переопределение метода __str__
        return f"BankAccount(account_number={self.account_number}, balance={self.balance})"

    def __repr__(self):  # Переопределение метода __repr__
        return f"BankAccount(account_number={self.account_number!r}, balance={self.balance!r})"

# Создание банковского счета BankAccount
my_account = BankAccount("123456789")

# Внесение суммы на счёт
my_account.deposit(-300)

# Снятие суммы со счёта
my_account.withdraw(-1000)

# Попытка снять больше, чем доступно на счёте
my_account.withdraw(1000)

# Вывод информации о счёте
print(my_account)

class BankAccount:
    species = 'Client account information'

    def __init__(self, account_number, balance):
        if not isinstance(balance, (int, float)) or balance < 0:
            raise TypeError('Amount must be more than 0')
        self.__account_number = account_number
        self.__balance = balance
        self._transactions_list = []

    def check_balance(self):
        return self.__balance

    def deposit(self, deposit_amount):
        if not isinstance(deposit_amount, (int, float)) or deposit_amount <= 0:
            raise TypeError('Amount must be more than 0')
        self.__balance += deposit_amount
        self._transactions_list.append(f'Deposit {deposit_amount}.')

    def withdraw(self, withdraw_amount):
        if not isinstance(withdraw_amount, (int, float)) or withdraw_amount <= 0:
            raise TypeError('Amount must be more than 0')
        if self.__balance > withdraw_amount:
            self.__balance -= withdraw_amount
            self._transactions_list.append(f'Withdraw {withdraw_amount}.')
        else:
            print('You do not have enough funds to withdraw.')

    def print_transactions(self):
        print(f'\nTransactions:')
        for transaction in self._transactions_list:
            print(transaction)


try:
    Client1 = BankAccount(account_number = 'BA 1001', balance = 100)
    print(f'Your balance: {Client1.check_balance()}')
    Client1.deposit(200)
    print(f'Your balance: {Client1.check_balance()}')
    Client1.withdraw(100)
    print(f'Your balance: {Client1.check_balance()}')
    Client1.print_transactions()
except TypeError as e:
    print(e)

class BankAccount:

    def __init__(self, account_number, balance=0):
        self.__account_number = account_number
        self.__balance = balance

    def deposit(self, cash):
        self.__balance += cash
        return f"Баланс пополнен на {cash}.Текущий баланс:{self.__balance}"

    def withdraw(self, cash):
        if self.__balance >= cash:
            self.__balance -= cash
            return f"Снятие со счета на сумму {cash}. Текущий баланс: {self.__balance}"
        return f"Недостаточно средств на счете"

    def get_account_balance(self):
        return f"Текущий баланс: {self.__balance}"

    def get_account_info(self):
        return f"Номер счета: {self.__account_number}, Баланс: {self.__balance}"


account = BankAccount(1009898070, 500)
print(account.get_account_info())
print(account.deposit(1000))
print(account.withdraw(100))
print(account.withdraw(1500))
print(account.get_account_balance())

class BankAccount:

    def __init__(self):
        self.account_number = 735562
        self.balance = 1000


    def deposit(self, dep_ammount):
        print(f"peeep.....peeeep....  {dep_ammount}$ have been added to your account")
        self.balance += dep_ammount
        self.check_balance()


    def withdraw(self, withdraw_ammount):
        if self.balance - withdraw_ammount < 0:
            print("Insufficient Funds")
            raise ValueError("Withdrawal amount exceeds available balance.")
        self.balance -= withdraw_ammount
        print(f"peeeep....peeeep... {withdraw_ammount}$ have been withdrawn from your account")
        self.check_balance()


    def check_balance(self):
        print(f"your current balance is: {self.balance}")

my_acc = BankAccount()
try:
    my_acc.withdraw(2800)
except ValueError as e:
    print(e)
my_acc.deposit(3798)

"""## Python fundamentals: Домашнее задание 31 (Python)

### 1.
Напишите декоратор validate_args, который будет проверять типы аргументов функции и выводить сообщение об ошибке, если переданы аргументы неправильного типа. Декоратор должен принимать ожидаемые типы аргументов в качестве параметров.


Пример использования:

```
@validate_args(int, str)

def greet(age, name):

    print(f"Привет, {name}! Тебе {age} лет.")


greet(25, "Анна")  # Все аргументы имеют правильные типы

greet("25", "Анна")  # Возникнет исключение TypeError
```

Ожидаемый вывод:


Привет, Анна! Тебе 25 лет.

TypeError: Аргумент 25 имеет неправильный тип <class 'str'>. Ожидается <class 'int'>.
"""

def validate_args(*types):
    def decorator(func):
        def wrapper(*args):
            # print("*" * 30)
            print("zip", list(zip(args, types)))
            for arg, expected_type in zip(args, types):
                if not isinstance(arg, expected_type):
                    raise TypeError(f"Аргумент {arg} имеет неправильный тип {type(arg)}. Ожидается {expected_type}")
            res = func(*args)
            # print("*" * 30)
            return res

        return wrapper

    return decorator


@validate_args(int, str)
def greet(age, name):
    print(f"Привет, {name}! Тебе {age} лет.")

@validate_args(str)
def greet2(name):
    print(f"Привет, {name}!")


greet(25, "Анна")
greet(30, "Антон")
# greet([1, 2], "Анна")
# greet('25', "Анна")

greet2("Анна")

# Определение декоратора, который принимает ожидаемые типы как аргументы
def validate_args(*expected_types):
    # Эта функция — сам декоратор
    def decorator(func):
        # Это обёртка, которая будет проверять аргументы перед вызовом функции
        def wrapper(*args):
            # Проходим по всем аргументам и соответствующим ожидаемым типам
            for i, (arg, expected_type) in enumerate(zip(args, expected_types)):
                # Если тип аргумента не совпадает с ожидаемым
                if not isinstance(arg, expected_type):
                    # Выводим ошибку и вызываем исключение TypeError
                    raise TypeError(f"Аргумент {arg} имеет неправильный тип {type(arg)}. Ожидается {expected_type}.")
            # Если всё ок — вызываем оригинальную функцию
            return func(*args)
        return wrapper
    return decorator


# Использование декоратора
@validate_args(int, str)  # Ожидаем: первый аргумент — int, второй — str
def greet(age, name):
    print(f"Привет, {name}! Тебе {age} лет.")

@validate_args(str)  # Ожидаем: первый аргумент — int, второй — str
def greet2(name):
    print(f"Привет, {name}!")


# Тест: правильные типы
greet(25, "Анна")  # Всё хорошо, выведет: Привет, Анна! Тебе 25 лет.
greet2("Анна")

# # Тест: неправильный тип (возникнет ошибка)
# greet("25", "Анна")  # Ошибка: первый аргумент — строка, а должен быть int

def validate_args(inp_int,inp_str) :
    def decorator(func) :
        def wrapper(*args,**kwargs):
            try:
                if not isinstance(args[0],inp_int) :
                    raise TypeError(f"Аргумент {args[0]} имеет неправильный тип {type(args[0])}. Ожидается {inp_int}.")
                if not isinstance(args[1],inp_str) :
                    raise TypeError(f"Аргумент {args[1]} имеет неправильный тип {type(args[1])}. Ожидается {inp_str}.")
            except TypeError as e :
                return e
            return func(*args,**kwargs)
        return  wrapper
    return decorator


@validate_args(int,str)
def greet(age, name):
     return f"Привет, {name}! Тебе {age} лет."

print(print_task_number(1))
print(greet('25', "Анна"))

"""### 2.
Напишите декоратор log_args, который будет записывать аргументы и результаты вызовов функции в лог-файл. Каждый вызов функции должен быть записан на новой строке в формате "Аргументы: <аргументы>, Результат: <результат>". Используйте модуль logging для записи в лог-файл.



Пример использования:


```python

@log_args

def add(a, b):

    return a + b


add(2, 3)

add(5, 7)
```

Ожидаемый вывод в файле log.txt:


Аргументы: 2, 3, Результат: 5

Аргументы: 5, 7, Результат: 12


Убедитесь, что перед запуском кода у вас создан файл log.txt в той же директории, где находится скрипт Python.


"""

import logging


def log_args(func):
    def wrapper(*args):
        # Настройка логирования уровня info
        logging.basicConfig(filename="log.txt",
                            format="%(asctime)s - %(filename)s - %(lineno)d - %(levelname)s - %(message)s",
                            level=logging.INFO,
                            encoding="utf-8"
                            )
        res = func(*args)
        logging.info(f"Аргументы: {args}. Результат: {res}")
        return res

    return wrapper


@log_args
def add(a, b):
    return a + b


print(add(2, 3))
print(add(5, 7))

import logging

# Настройка логирования: запись в файл HW_31_log.txt, режим дозаписи
logging.basicConfig(
    filename='HW_31_log.txt',      # имя файла
    level=logging.INFO,      # уровень логирования
    format='%(message)s'     # только сообщение (без даты и уровня)
)

# Декоратор log_args
def log_args(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)  # вызываем оригинальную функцию
        # Формируем строку для лога
        arg_str = ', '.join(map(str, args))
        log_line = f"Аргументы: {arg_str}, Результат: {result}"
        logging.info(log_line)  # записываем строку в лог-файл
        return result  # возвращаем результат вызова функции
    return wrapper

# Пример функции с декоратором
@log_args
def add(a, b):
    return a + b

# Тестовые вызовы
add(2, 3)
add(5, 7)

"""## ---"""

class Student:
    '''
    Students registration.

    Adding student name, age, grades. Calculate average grade.
    '''
    species = 'Student information'

    def __init__(self, name, age):
        if not isinstance(name, str):
            raise TypeError('Wrong input. Name must be a string')
        if not isinstance(age, int):
            raise TypeError('Wrong input. Age must be an integer')
        if age < 16:
            raise ValueError('Age must be at least 16')

        self.__name = name
        self.__age = age
        self.__grades = []

    def __str__(self):
        return f'Student name: {self.__name}, Age: {self.__age}'

    def __repr__(self):
        return f'Student name: {self.__name!r}, Age: {self.__age!r}, Grades: {self.__grades!r}'

    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def set_name(self, new_name):
        if isinstance(new_name, str):
            self.__name = new_name
        else:
            raise TypeError('Wrong input. Name must be a string.')

    def set_age(self, new_age):
        if not isinstance(new_age, int):
            raise TypeError('Wrong input. Age must be an integer')
        if not 16 <= new_age <= 80:
            raise ValueError('Wrong input. Age must be between 16 and 80.')

        self.__age = new_age


    def get_grades(self):
        if self.__grades:
            return self.__grades.copy()

    def add_grade(self, grade):
        if not isinstance(grade, int):
            raise TypeError('Wrong input. Grade must be an integer')
        if not 1 <= grade <= 5:
            raise ValueError('Wrong input. Grade must be between 1 and 5.')
        self.__grades.append(grade)

    def get_average_grade(self):
        if self.__grades:
            return round(sum(self.__grades) / len(self.__grades), 2)

try:
    student1 = Student("Alex", 18)

    print(f'Student name: {student1.get_name()}')
    print(f'Student age: {student1.get_age()}')

    student1.add_grade(5)
    student1.add_grade(3)
    student1.add_grade(4)

    print(repr(student1))
    print(f'Student grades: {student1.get_grades()}')
    print(f'Student average grade is: {student1.get_average_grade()}')

    student1.set_age(15)

except TypeError as e:
    print(e)
except ValueError as e:
    print(e)